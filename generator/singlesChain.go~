/*
 * Copyright Â© 2020, G.Ralph Kuntz, MD.
 *
 * Licensed under the Apache License, Version 2.0(the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIC
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package generator

import (
	"log"
	"os"
)

type (
	color uint8

	pair struct {
		left, right point
	}
)

const (
	black color = iota
	red
	blue
)

// singlesChain removes candidates by two methods. Prior to removing any candidates, chains are created between cells that contain the only two occurances of a digit in a unit (box, row, or column). The chains connect the units together through the doubly occurring digits. Starting at an arbitrary location in the chain, the cells are alternately colored with two different colors. "Twice in a unit": if the same color occurs twice in a single unit, all cells marked with that color anywhere in the puzzle can be removed. "Two colors elsewhere": if a non-chain cell containing the digit can "see" two cells colored with opposite colors, the digit can be removing from the non-chain cell.
func (g *Grid) singlesChain() (res bool) {
	g.Display()
	// Create a pairs set containing cells where the cells contain the only two occurrances of a digit in the unit. We use a set so that the pairs are unique.
	var pairMaps [10]map[pair]bool
	g.unitPairs(&pairMaps)

	// Color the points in the chains.
	for d := 1; d <= 9; d++ {
		log.Printf("digit: %d", d) // DEBUG
		for len(pairMaps[d]) != 0 {
			log.Printf("starting pairMaps: %v", pairMaps[d]) // DEBUG
			colors := make(map[point]color)

			var p pair
			for m := range pairMaps[d] { // Remove an item from the pairMaps for the current digit.
				p = m
				delete(pairMaps[d], m)
				break
			}

			if !setColors(p, &colors, &pairMaps[d], true) {
				continue
			}

			for {
				changed := false
				for p := range pairMaps[d] {
					log.Printf("inside pairMaps: %v", pairMaps[d]) // DEBUG
					if setColors(p, &colors, &pairMaps[d], false) {
						changed = true
						delete(pairMaps[d], p)
					}
				}
				if !changed {
					log.Print("no changes") // DEBUG
					break
				}
			}
			log.Printf("colors: %v", colors) // DEBUG
		}
		os.Exit(0)
	}

	return
}

func (g *Grid) unitPairs(pairMaps *[10]map[pair]bool) {
	g.unitPairsGroup(&box, pairMaps)
	g.unitPairsGroup(&col, pairMaps)
	g.unitPairsGroup(&row, pairMaps)
}

func (g *Grid) unitPairsGroup(gr *group, pairMaps *[10]map[pair]bool) {
	for _, ps := range gr.unit {
		digits := g.digitPoints(ps)

		for d := uint16(1); d <= 9; d++ {
			points := digits[d]
			if len(points) != 2 {
				continue
			}

			if g.orig[points[0].r][points[0].c] || g.orig[points[1].r][points[1].c] {
				continue
			}

			if (*pairMaps)[d] == nil {
				(*pairMaps)[d] = make(map[pair]bool)
			}
			(*pairMaps)[d][pair{points[0], points[1]}] = true
		}
	}
}

func setColors(p pair, colors *map[point]color, pairMap *map[pair]bool, colorBoth bool) bool {
	colorLeft := (*colors)[p.left]
	colorRight := (*colors)[p.right]

	if colorLeft == black && colorRight == black {
		if colorBoth {
			log.Printf("coloring first item in a chain: %v", p) // DEBUG
			(*colors)[p.left] = red
			(*colors)[p.right] = blue
			return true
		}
		log.Printf("not part of a chain: %v", p) // DEBUG
		return false
	}

	if colorLeft == red && colorRight == black {
		log.Printf("coloring right item blue: %v", p) // DEBUG
		(*colors)[p.right] = blue
		return true
	}

	if colorLeft == blue && colorRight == black {
		log.Printf("coloring right item red: %v", p) // DEBUG
		(*colors)[p.right] = red
		return true
	}

	if colorRight == red && colorLeft == black {
		log.Printf("coloring left item blue: %v", p) // DEBUG
		(*colors)[p.left] = blue
		return true
	}

	if colorRight == blue && colorLeft == black {
		log.Printf("coloring left item red: %v", p) // DEBUG
		(*colors)[p.left] = red
		return true
	}

	log.Printf("skipping pair %v, already colored", p) // DEBUG
	delete(*pairMap, p)
	return false
}
